name: Docker Deploy

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Determine deployment environment and strategy
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    steps:
      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Check if deployment should proceed
        id: check
        run: |
          # Add logic to determine if deployment should proceed
          # For example, check if there are any critical issues, maintenance windows, etc.
          echo "should_deploy=true" >> $GITHUB_OUTPUT

  # Build and push production Docker images
  build-and-push:
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_deploy == 'true'
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        service: [frontend, server]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ needs.setup.outputs.environment }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.${{ matrix.service }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

  # Deploy using Docker Compose
  deploy:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push]
    environment: ${{ needs.setup.outputs.environment }}
    if: needs.setup.outputs.should_deploy == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Deploy to staging
        if: needs.setup.outputs.environment == 'staging'
        run: |
          echo "ðŸš€ Deploying to staging environment"
          
          # Example deployment to staging server
          # Replace with your actual deployment commands
          
          # Option 1: Deploy to staging server via SSH
          # ssh staging-server "cd /app && docker-compose pull && docker-compose up -d"
          
          # Option 2: Deploy to cloud platform
          # docker-compose -f docker-compose.staging.yml up -d
          
          echo "âœ… Staging deployment completed"

      - name: Deploy to production
        if: needs.setup.outputs.environment == 'production'
        run: |
          echo "ðŸš€ Deploying to production environment"
          
          # Example production deployment with blue-green strategy
          # Replace with your actual deployment commands
          
          # Option 1: Deploy to production servers via SSH
          # ssh production-server "cd /app && docker-compose -f docker-compose.prod.yml pull"
          # ssh production-server "cd /app && docker-compose -f docker-compose.prod.yml up -d"
          
          # Option 2: Deploy to Kubernetes
          # kubectl set image deployment/frontend frontend=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:${{ github.sha }}
          # kubectl set image deployment/server server=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-server:${{ github.sha }}
          
          echo "âœ… Production deployment completed"

  # Health checks and smoke tests
  health-check:
    runs-on: ubuntu-latest
    needs: [setup, deploy]
    if: always() && needs.setup.outputs.should_deploy == 'true'
    steps:
      - name: Wait for deployment to stabilize
        run: sleep 30

      - name: Health check GraphQL server
        run: |
          if [ "${{ needs.setup.outputs.environment }}" = "staging" ]; then
            GRAPHQL_URL="https://staging-api.yourdomain.com/graphql"
          else
            GRAPHQL_URL="https://api.yourdomain.com/graphql"
          fi
          
          echo "ðŸ” Checking GraphQL server health at $GRAPHQL_URL"
          
          # Basic health check
          response=$(curl -s -o /dev/null -w "%{http_code}" "$GRAPHQL_URL" || echo "000")
          
          if [ "$response" = "200" ] || [ "$response" = "400" ]; then
            echo "âœ… GraphQL server is responding"
          else
            echo "âŒ GraphQL server health check failed (HTTP $response)"
            exit 1
          fi

      - name: Health check frontend
        run: |
          if [ "${{ needs.setup.outputs.environment }}" = "staging" ]; then
            FRONTEND_URL="https://staging.yourdomain.com"
          else
            FRONTEND_URL="https://yourdomain.com"
          fi
          
          echo "ðŸ” Checking frontend health at $FRONTEND_URL"
          
          # Basic health check
          response=$(curl -s -o /dev/null -w "%{http_code}" "$FRONTEND_URL" || echo "000")
          
          if [ "$response" = "200" ]; then
            echo "âœ… Frontend is responding"
          else
            echo "âŒ Frontend health check failed (HTTP $response)"
            exit 1
          fi

      - name: Run smoke tests
        run: |
          echo "ðŸ§ª Running smoke tests"
          
          # Add your smoke tests here
          # Example: Test critical user journeys, API endpoints, etc.
          
          echo "âœ… Smoke tests passed"

  # Rollback mechanism
  rollback:
    runs-on: ubuntu-latest
    needs: [setup, health-check]
    if: failure() && needs.setup.outputs.should_deploy == 'true'
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - name: Rollback deployment
        run: |
          echo "ðŸ”„ Rolling back deployment for ${{ needs.setup.outputs.environment }}"
          
          # Add rollback commands here
          # Example: Deploy previous known good images
          # docker-compose -f docker-compose.yml pull --ignore-pull-failures
          # docker-compose -f docker-compose.yml up -d
          
          echo "âœ… Rollback completed"

  # Notify deployment status
  notify:
    runs-on: ubuntu-latest
    needs: [setup, deploy, health-check]
    if: always() && needs.setup.outputs.should_deploy == 'true'
    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [ "${{ needs.health-check.result }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=âœ… Deployment to ${{ needs.setup.outputs.environment }} successful" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=âŒ Deployment to ${{ needs.setup.outputs.environment }} failed" >> $GITHUB_OUTPUT
          fi

      - name: Notify team
        run: |
          echo "${{ steps.status.outputs.message }}"
          
          # Add notification commands here
          # Example: Slack notification, email, etc.
          
          # Slack webhook example:
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"${{ steps.status.outputs.message }}"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}
          
          # Teams webhook example:
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"${{ steps.status.outputs.message }}"}' \
          #   ${{ secrets.TEAMS_WEBHOOK_URL }}